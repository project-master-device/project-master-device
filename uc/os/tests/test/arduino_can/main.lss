
main.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000004  00800100  000008e0  00000974  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000008e0  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000004  00800104  00800104  00000978  2**0
                  ALLOC
  3 .stab         000006b4  00000000  00000000  00000978  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000054  00000000  00000000  0000102c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000000c0  00000000  00000000  00001080  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000395  00000000  00000000  00001140  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   000010be  00000000  00000000  000014d5  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000726  00000000  00000000  00002593  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000d50  00000000  00000000  00002cb9  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000280  00000000  00000000  00003a0c  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000004bc  00000000  00000000  00003c8c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00000860  00000000  00000000  00004148  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000100  00000000  00000000  000049a8  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
   4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
   8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
   c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  2c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  40:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  48:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
  68:	11 24       	eor	r1, r1
  6a:	1f be       	out	0x3f, r1	; 63
  6c:	cf ef       	ldi	r28, 0xFF	; 255
  6e:	d4 e0       	ldi	r29, 0x04	; 4
  70:	de bf       	out	0x3e, r29	; 62
  72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
  74:	11 e0       	ldi	r17, 0x01	; 1
  76:	a0 e0       	ldi	r26, 0x00	; 0
  78:	b1 e0       	ldi	r27, 0x01	; 1
  7a:	e0 ee       	ldi	r30, 0xE0	; 224
  7c:	f8 e0       	ldi	r31, 0x08	; 8
  7e:	02 c0       	rjmp	.+4      	; 0x84 <.do_copy_data_start>

00000080 <.do_copy_data_loop>:
  80:	05 90       	lpm	r0, Z+
  82:	0d 92       	st	X+, r0

00000084 <.do_copy_data_start>:
  84:	a4 30       	cpi	r26, 0x04	; 4
  86:	b1 07       	cpc	r27, r17
  88:	d9 f7       	brne	.-10     	; 0x80 <.do_copy_data_loop>

0000008a <__do_clear_bss>:
  8a:	11 e0       	ldi	r17, 0x01	; 1
  8c:	a4 e0       	ldi	r26, 0x04	; 4
  8e:	b1 e0       	ldi	r27, 0x01	; 1
  90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
  92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
  94:	a8 30       	cpi	r26, 0x08	; 8
  96:	b1 07       	cpc	r27, r17
  98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
  9a:	0e 94 53 00 	call	0xa6	; 0xa6 <main>
  9e:	0c 94 6e 04 	jmp	0x8dc	; 0x8dc <_exit>

000000a2 <__bad_interrupt>:
  a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <main>:

    spi_init();
    setup_can();
}

int main() {
  a6:	3f 92       	push	r3
  a8:	4f 92       	push	r4
  aa:	5f 92       	push	r5
  ac:	6f 92       	push	r6
  ae:	7f 92       	push	r7
  b0:	8f 92       	push	r8
  b2:	9f 92       	push	r9
  b4:	af 92       	push	r10
  b6:	bf 92       	push	r11
  b8:	cf 92       	push	r12
  ba:	df 92       	push	r13
  bc:	ef 92       	push	r14
  be:	ff 92       	push	r15
  c0:	0f 93       	push	r16
  c2:	1f 93       	push	r17
  c4:	df 93       	push	r29
  c6:	cf 93       	push	r28
  c8:	cd b7       	in	r28, 0x3d	; 61
  ca:	de b7       	in	r29, 0x3e	; 62
  cc:	60 97       	sbiw	r28, 0x10	; 16
  ce:	0f b6       	in	r0, 0x3f	; 63
  d0:	f8 94       	cli
  d2:	de bf       	out	0x3e, r29	; 62
  d4:	0f be       	out	0x3f, r0	; 63
  d6:	cd bf       	out	0x3d, r28	; 61

static void setup_all() {
    //init();

    // Set led pin's output mode
    DDRD  |=  ((1 << PD2) | (1 << PD4));
  d8:	8a b1       	in	r24, 0x0a	; 10
  da:	84 61       	ori	r24, 0x14	; 20
  dc:	8a b9       	out	0x0a, r24	; 10
static void blink_err_led() {
    PORTD ^= (1 << PD2);
}

static void off_err_led() {
    PORTD &= ~(1 << PD2);
  de:	5a 98       	cbi	0x0b, 2	; 11
static void blink_ok_led() {
    PORTD ^= (1 << PD4);
}

static void off_ok_led() {
    PORTD &= ~(1 << PD4);
  e0:	5c 98       	cbi	0x0b, 4	; 11
    off_err_led();
    off_ok_led();
 
////timebase_init();

    spi_init();
  e2:	0e 94 8e 01 	call	0x31c	; 0x31c <spi_init>
    }
}

static void setup_can() {

    uint8_t res = can_init(CAN_125KBPS);
  e6:	82 e0       	ldi	r24, 0x02	; 2
  e8:	0e 94 89 01 	call	0x312	; 0x312 <can_init>

	if (res != CAN_OK) {
  ec:	88 23       	and	r24, r24
  ee:	a1 f0       	breq	.+40     	; 0x118 <main+0x72>
  f0:	20 e3       	ldi	r18, 0x30	; 48
  f2:	35 e7       	ldi	r19, 0x75	; 117
#define ERR_SIG_NUMBER          4

unsigned int send_errors = 0;

static void blink_err_led() {
    PORTD ^= (1 << PD2);
  f4:	64 e0       	ldi	r22, 0x04	; 4
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
  f6:	40 e9       	ldi	r20, 0x90	; 144
  f8:	51 e0       	ldi	r21, 0x01	; 1
  fa:	05 c0       	rjmp	.+10     	; 0x106 <main+0x60>
  fc:	ca 01       	movw	r24, r20
  fe:	01 97       	sbiw	r24, 0x01	; 1
 100:	f1 f7       	brne	.-4      	; 0xfe <main+0x58>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 102:	21 50       	subi	r18, 0x01	; 1
 104:	30 40       	sbci	r19, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 106:	21 15       	cp	r18, r1
 108:	31 05       	cpc	r19, r1
 10a:	c1 f7       	brne	.-16     	; 0xfc <main+0x56>
 10c:	8b b1       	in	r24, 0x0b	; 11
 10e:	86 27       	eor	r24, r22
 110:	8b b9       	out	0x0b, r24	; 11
 112:	20 e3       	ldi	r18, 0x30	; 48
 114:	35 e7       	ldi	r19, 0x75	; 117
 116:	f2 cf       	rjmp	.-28     	; 0xfc <main+0x56>
            _delay_ms(3000);
            blink_err_led();
        }
    }

    res = mcp2515_setCANCTRL_Mode(MODE_NORMAL);
 118:	80 e0       	ldi	r24, 0x00	; 0
 11a:	0e 94 01 04 	call	0x802	; 0x802 <mcp2515_setCANCTRL_Mode>
	if (res != MCP2515_OK) {
 11e:	88 23       	and	r24, r24
 120:	a1 f0       	breq	.+40     	; 0x14a <main+0xa4>
 122:	20 e1       	ldi	r18, 0x10	; 16
 124:	37 e2       	ldi	r19, 0x27	; 39
#define ERR_SIG_NUMBER          4

unsigned int send_errors = 0;

static void blink_err_led() {
    PORTD ^= (1 << PD2);
 126:	64 e0       	ldi	r22, 0x04	; 4
 128:	40 e9       	ldi	r20, 0x90	; 144
 12a:	51 e0       	ldi	r21, 0x01	; 1
 12c:	05 c0       	rjmp	.+10     	; 0x138 <main+0x92>
 12e:	ca 01       	movw	r24, r20
 130:	01 97       	sbiw	r24, 0x01	; 1
 132:	f1 f7       	brne	.-4      	; 0x130 <main+0x8a>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 134:	21 50       	subi	r18, 0x01	; 1
 136:	30 40       	sbci	r19, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 138:	21 15       	cp	r18, r1
 13a:	31 05       	cpc	r19, r1
 13c:	c1 f7       	brne	.-16     	; 0x12e <main+0x88>
 13e:	8b b1       	in	r24, 0x0b	; 11
 140:	86 27       	eor	r24, r22
 142:	8b b9       	out	0x0b, r24	; 11
 144:	20 e1       	ldi	r18, 0x10	; 16
 146:	37 e2       	ldi	r19, 0x27	; 39
 148:	f2 cf       	rjmp	.-28     	; 0x12e <main+0x88>
static void on_err_led() {
    PORTD |= (1 << PD2);
}

static void blink_ok_led() {
    PORTD ^= (1 << PD4);
 14a:	50 e1       	ldi	r21, 0x10	; 16
 14c:	35 2e       	mov	r3, r21
 14e:	00 e9       	ldi	r16, 0x90	; 144
 150:	11 e0       	ldi	r17, 0x01	; 1
static void send_can_msg() {
    int i = 0;
    int j = 0;

    CanMessage msg;
    can_initMessageStruct(&msg);
 152:	5e 01       	movw	r10, r28
 154:	08 94       	sec
 156:	a1 1c       	adc	r10, r1
 158:	b1 1c       	adc	r11, r1
 15a:	47 e0       	ldi	r20, 0x07	; 7
 15c:	64 2e       	mov	r6, r20
 15e:	71 2c       	mov	r7, r1
 160:	6c 0e       	add	r6, r28
 162:	7d 1e       	adc	r7, r29

    msg.identifier = CANDEFAULTIDENT;

    for(; i < CAN_MAX_CHAR_IN_MESSAGE; ++i) {
 164:	3f e0       	ldi	r19, 0x0F	; 15
 166:	83 2e       	mov	r8, r19
 168:	91 2c       	mov	r9, r1
 16a:	8c 0e       	add	r8, r28
 16c:	9d 1e       	adc	r9, r29
        msg.dta[i] = 0;
    }
    
    msg.dta[SEND_DATA_BYTE] = SEND_DATA_BYTE_VALUE;
 16e:	23 e0       	ldi	r18, 0x03	; 3
 170:	42 2e       	mov	r4, r18
    int j = 0;

    CanMessage msg;
    can_initMessageStruct(&msg);

    msg.identifier = CANDEFAULTIDENT;
 172:	9c ec       	ldi	r25, 0xCC	; 204
 174:	c9 2e       	mov	r12, r25
 176:	95 e5       	ldi	r25, 0x55	; 85
 178:	d9 2e       	mov	r13, r25
 17a:	e1 2c       	mov	r14, r1
 17c:	f1 2c       	mov	r15, r1
#define ERR_SIG_NUMBER          4

unsigned int send_errors = 0;

static void blink_err_led() {
    PORTD ^= (1 << PD2);
 17e:	84 e0       	ldi	r24, 0x04	; 4
 180:	58 2e       	mov	r5, r24
static void on_err_led() {
    PORTD |= (1 << PD2);
}

static void blink_ok_led() {
    PORTD ^= (1 << PD4);
 182:	8b b1       	in	r24, 0x0b	; 11
 184:	83 25       	eor	r24, r3
 186:	8b b9       	out	0x0b, r24	; 11
 188:	88 e8       	ldi	r24, 0x88	; 136
 18a:	93 e1       	ldi	r25, 0x13	; 19
 18c:	f8 01       	movw	r30, r16
 18e:	31 97       	sbiw	r30, 0x01	; 1
 190:	f1 f7       	brne	.-4      	; 0x18e <main+0xe8>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 192:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 194:	d9 f7       	brne	.-10     	; 0x18c <main+0xe6>
static void send_can_msg() {
    int i = 0;
    int j = 0;

    CanMessage msg;
    can_initMessageStruct(&msg);
 196:	c5 01       	movw	r24, r10
 198:	0e 94 82 01 	call	0x304	; 0x304 <can_initMessageStruct>
 19c:	f3 01       	movw	r30, r6

    msg.identifier = CANDEFAULTIDENT;

    for(; i < CAN_MAX_CHAR_IN_MESSAGE; ++i) {
        msg.dta[i] = 0;
 19e:	11 92       	st	Z+, r1
    CanMessage msg;
    can_initMessageStruct(&msg);

    msg.identifier = CANDEFAULTIDENT;

    for(; i < CAN_MAX_CHAR_IN_MESSAGE; ++i) {
 1a0:	e8 15       	cp	r30, r8
 1a2:	f9 05       	cpc	r31, r9
 1a4:	e1 f7       	brne	.-8      	; 0x19e <main+0xf8>
        msg.dta[i] = 0;
    }
    
    msg.dta[SEND_DATA_BYTE] = SEND_DATA_BYTE_VALUE;
 1a6:	4f 82       	std	Y+7, r4	; 0x07
    int j = 0;

    CanMessage msg;
    can_initMessageStruct(&msg);

    msg.identifier = CANDEFAULTIDENT;
 1a8:	ca 82       	std	Y+2, r12	; 0x02
 1aa:	db 82       	std	Y+3, r13	; 0x03
 1ac:	ec 82       	std	Y+4, r14	; 0x04
 1ae:	fd 82       	std	Y+5, r15	; 0x05
        msg.dta[i] = 0;
    }
    
    msg.dta[SEND_DATA_BYTE] = SEND_DATA_BYTE_VALUE;

    if(can_sendMessage(&msg) != CAN_OK) {
 1b0:	c5 01       	movw	r24, r10
 1b2:	0e 94 45 01 	call	0x28a	; 0x28a <can_sendMessage>
 1b6:	88 23       	and	r24, r24
 1b8:	01 f1       	breq	.+64     	; 0x1fa <main+0x154>
        send_errors += 1;
 1ba:	80 91 04 01 	lds	r24, 0x0104
 1be:	90 91 05 01 	lds	r25, 0x0105
 1c2:	01 96       	adiw	r24, 0x01	; 1
 1c4:	90 93 05 01 	sts	0x0105, r25
 1c8:	80 93 04 01 	sts	0x0104, r24

        if(send_errors == SEND_ERR_MAX) {
 1cc:	01 97       	sbiw	r24, 0x01	; 1
 1ce:	a9 f4       	brne	.+42     	; 0x1fa <main+0x154>
 1d0:	20 e0       	ldi	r18, 0x00	; 0
 1d2:	30 e0       	ldi	r19, 0x00	; 0
#define ERR_SIG_NUMBER          4

unsigned int send_errors = 0;

static void blink_err_led() {
    PORTD ^= (1 << PD2);
 1d4:	8b b1       	in	r24, 0x0b	; 11
 1d6:	85 25       	eor	r24, r5
 1d8:	8b b9       	out	0x0b, r24	; 11
 1da:	88 ee       	ldi	r24, 0xE8	; 232
 1dc:	93 e0       	ldi	r25, 0x03	; 3
 1de:	f8 01       	movw	r30, r16
 1e0:	31 97       	sbiw	r30, 0x01	; 1
 1e2:	f1 f7       	brne	.-4      	; 0x1e0 <main+0x13a>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 1e4:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 1e6:	d9 f7       	brne	.-10     	; 0x1de <main+0x138>
    if(can_sendMessage(&msg) != CAN_OK) {
        send_errors += 1;

        if(send_errors == SEND_ERR_MAX) {
            // Bad news
            for(j = 0; j < SEND_ERR_SIG_NUMBER; ++j) {
 1e8:	2f 5f       	subi	r18, 0xFF	; 255
 1ea:	3f 4f       	sbci	r19, 0xFF	; 255
 1ec:	2a 30       	cpi	r18, 0x0A	; 10
 1ee:	31 05       	cpc	r19, r1
 1f0:	89 f7       	brne	.-30     	; 0x1d4 <main+0x12e>
                blink_err_led();
                _delay_ms(100);
            }
            send_errors = 0;
 1f2:	10 92 05 01 	sts	0x0105, r1
 1f6:	10 92 04 01 	sts	0x0104, r1
        }
    }

    if(can_checkError() != CAN_OK) {
 1fa:	0e 94 14 01 	call	0x228	; 0x228 <can_checkError>
 1fe:	88 23       	and	r24, r24
 200:	09 f4       	brne	.+2      	; 0x204 <main+0x15e>
 202:	bf cf       	rjmp	.-130    	; 0x182 <main+0xdc>
 204:	20 e0       	ldi	r18, 0x00	; 0
 206:	30 e0       	ldi	r19, 0x00	; 0
#define ERR_SIG_NUMBER          4

unsigned int send_errors = 0;

static void blink_err_led() {
    PORTD ^= (1 << PD2);
 208:	8b b1       	in	r24, 0x0b	; 11
 20a:	85 25       	eor	r24, r5
 20c:	8b b9       	out	0x0b, r24	; 11
 20e:	88 e8       	ldi	r24, 0x88	; 136
 210:	93 e1       	ldi	r25, 0x13	; 19
 212:	f8 01       	movw	r30, r16
 214:	31 97       	sbiw	r30, 0x01	; 1
 216:	f1 f7       	brne	.-4      	; 0x214 <main+0x16e>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 218:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 21a:	d9 f7       	brne	.-10     	; 0x212 <main+0x16c>
            send_errors = 0;
        }
    }

    if(can_checkError() != CAN_OK) {
        for(j = 0; j < ERR_SIG_NUMBER; ++j) {
 21c:	2f 5f       	subi	r18, 0xFF	; 255
 21e:	3f 4f       	sbci	r19, 0xFF	; 255
 220:	24 30       	cpi	r18, 0x04	; 4
 222:	31 05       	cpc	r19, r1
 224:	89 f7       	brne	.-30     	; 0x208 <main+0x162>
 226:	ad cf       	rjmp	.-166    	; 0x182 <main+0xdc>

00000228 <can_checkError>:

/* checks Controller-Error-State, returns CAN_OK or CAN_CTRLERROR 
   only errors (and not warnings) lead to "CTRLERROR" */
uint8_t can_checkError(void)
{
	uint8_t eflg = mcp2515_readRegister(MCP_EFLG);
 228:	8d e2       	ldi	r24, 0x2D	; 45
 22a:	0e 94 77 03 	call	0x6ee	; 0x6ee <mcp2515_readRegister>

	if ( eflg & MCP_EFLG_ERRORMASK ) {
 22e:	88 7f       	andi	r24, 0xF8	; 248
 230:	09 f0       	breq	.+2      	; 0x234 <can_checkError+0xc>
 232:	85 e0       	ldi	r24, 0x05	; 5
		return CAN_CTRLERROR;
	}
	else {
		return CAN_OK;
	}
}
 234:	08 95       	ret

00000236 <can_checkReceive>:
*/
uint8_t can_checkReceive(void)
{
	uint8_t res;
	
	res = mcp2515_readStatus(); // RXnIF in Bit 1 and 0
 236:	0e 94 eb 02 	call	0x5d6	; 0x5d6 <mcp2515_readStatus>
	if ( res & MCP_STAT_RXIF_MASK ) {
 23a:	90 e0       	ldi	r25, 0x00	; 0
 23c:	83 70       	andi	r24, 0x03	; 3
 23e:	90 70       	andi	r25, 0x00	; 0
 240:	89 2b       	or	r24, r25
 242:	11 f4       	brne	.+4      	; 0x248 <can_checkReceive+0x12>
 244:	84 e0       	ldi	r24, 0x04	; 4
 246:	08 95       	ret
 248:	83 e0       	ldi	r24, 0x03	; 3
		return CAN_MSGAVAIL;
	}
	else {
		return CAN_NOMSG;
	}
}
 24a:	08 95       	ret

0000024c <can_readMessage>:
		return CAN_FAILTX;
	}
}

uint8_t can_readMessage(CanMessage *msg)
{
 24c:	cf 93       	push	r28
 24e:	df 93       	push	r29
 250:	ec 01       	movw	r28, r24
	uint8_t stat, res;
	
	stat = mcp2515_readStatus();
 252:	0e 94 eb 02 	call	0x5d6	; 0x5d6 <mcp2515_readStatus>
	
	if ( stat & MCP_STAT_RX0IF ) {
 256:	80 ff       	sbrs	r24, 0
 258:	07 c0       	rjmp	.+14     	; 0x268 <can_readMessage+0x1c>
		// Msg in Buffer 0
		mcp2515_read_canMsg( MCP_RXBUF_0, msg);
 25a:	81 e6       	ldi	r24, 0x61	; 97
 25c:	be 01       	movw	r22, r28
 25e:	0e 94 d8 03 	call	0x7b0	; 0x7b0 <mcp2515_read_canMsg>
		mcp2515_modifyRegister(MCP_CANINTF, MCP_RX0IF, 0);
 262:	8c e2       	ldi	r24, 0x2C	; 44
 264:	61 e0       	ldi	r22, 0x01	; 1
 266:	0a c0       	rjmp	.+20     	; 0x27c <can_readMessage+0x30>
		res = CAN_OK;
	}
	else if ( stat & MCP_STAT_RX1IF ) {
 268:	81 fd       	sbrc	r24, 1
 26a:	02 c0       	rjmp	.+4      	; 0x270 <can_readMessage+0x24>
 26c:	84 e0       	ldi	r24, 0x04	; 4
 26e:	0a c0       	rjmp	.+20     	; 0x284 <can_readMessage+0x38>
		// Msg in Buffer 1
		mcp2515_read_canMsg( MCP_RXBUF_1, msg);
 270:	81 e7       	ldi	r24, 0x71	; 113
 272:	be 01       	movw	r22, r28
 274:	0e 94 d8 03 	call	0x7b0	; 0x7b0 <mcp2515_read_canMsg>
		mcp2515_modifyRegister(MCP_CANINTF, MCP_RX1IF, 0);
 278:	8c e2       	ldi	r24, 0x2C	; 44
 27a:	62 e0       	ldi	r22, 0x02	; 2
 27c:	40 e0       	ldi	r20, 0x00	; 0
 27e:	0e 94 a7 01 	call	0x34e	; 0x34e <mcp2515_modifyRegister>
 282:	80 e0       	ldi	r24, 0x00	; 0
	else {
		res = CAN_NOMSG;
	}	
	
	return res;
}
 284:	df 91       	pop	r29
 286:	cf 91       	pop	r28
 288:	08 95       	ret

0000028a <can_sendMessage>:
{
	memset(msg,0,sizeof(CanMessage));
}

uint8_t can_sendMessage(const CanMessage* msg)
{
 28a:	af 92       	push	r10
 28c:	bf 92       	push	r11
 28e:	cf 92       	push	r12
 290:	df 92       	push	r13
 292:	ff 92       	push	r15
 294:	0f 93       	push	r16
 296:	1f 93       	push	r17
 298:	df 93       	push	r29
 29a:	cf 93       	push	r28
 29c:	0f 92       	push	r0
 29e:	cd b7       	in	r28, 0x3d	; 61
 2a0:	de b7       	in	r29, 0x3e	; 62
 2a2:	6c 01       	movw	r12, r24
	uint8_t res, txbuf_n;
	uint8_t timeout = 0;
	uint16_t time;
	
	time = timebase_actTime();
 2a4:	0e 94 4d 04 	call	0x89a	; 0x89a <timebase_actTime>
 2a8:	8c 01       	movw	r16, r24
	
	do {
		res = mcp2515_getNextFreeTXBuf(&txbuf_n); // info = addr.
 2aa:	5e 01       	movw	r10, r28
 2ac:	08 94       	sec
 2ae:	a1 1c       	adc	r10, r1
 2b0:	b1 1c       	adc	r11, r1
 2b2:	c5 01       	movw	r24, r10
 2b4:	0e 94 98 03 	call	0x730	; 0x730 <mcp2515_getNextFreeTXBuf>
 2b8:	f8 2e       	mov	r15, r24
		if (timebase_passedTimeMS(time) > CANSENDTIMEOUT ) timeout = 1;
 2ba:	c8 01       	movw	r24, r16
 2bc:	0e 94 56 04 	call	0x8ac	; 0x8ac <timebase_passedTimeMS>
 2c0:	20 e0       	ldi	r18, 0x00	; 0
 2c2:	89 3c       	cpi	r24, 0xC9	; 201
 2c4:	91 05       	cpc	r25, r1
 2c6:	08 f0       	brcs	.+2      	; 0x2ca <can_sendMessage+0x40>
 2c8:	21 e0       	ldi	r18, 0x01	; 1
	} while (res == MCP_ALLTXBUSY && !timeout);
 2ca:	82 e0       	ldi	r24, 0x02	; 2
 2cc:	f8 16       	cp	r15, r24
 2ce:	19 f4       	brne	.+6      	; 0x2d6 <can_sendMessage+0x4c>
 2d0:	22 23       	and	r18, r18
 2d2:	79 f3       	breq	.-34     	; 0x2b2 <can_sendMessage+0x28>
 2d4:	0b c0       	rjmp	.+22     	; 0x2ec <can_sendMessage+0x62>
	
	if (!timeout) {
 2d6:	22 23       	and	r18, r18
 2d8:	49 f4       	brne	.+18     	; 0x2ec <can_sendMessage+0x62>
		mcp2515_write_canMsg( txbuf_n, msg);
 2da:	89 81       	ldd	r24, Y+1	; 0x01
 2dc:	b6 01       	movw	r22, r12
 2de:	0e 94 9b 02 	call	0x536	; 0x536 <mcp2515_write_canMsg>
		mcp2515_start_transmit( txbuf_n );
 2e2:	89 81       	ldd	r24, Y+1	; 0x01
 2e4:	0e 94 bf 01 	call	0x37e	; 0x37e <mcp2515_start_transmit>
 2e8:	80 e0       	ldi	r24, 0x00	; 0
 2ea:	01 c0       	rjmp	.+2      	; 0x2ee <can_sendMessage+0x64>
		return CAN_OK;
 2ec:	82 e0       	ldi	r24, 0x02	; 2
#if (CANDEBUG)
		term_puts_P("Transmit timeout\n");
#endif
		return CAN_FAILTX;
	}
}
 2ee:	0f 90       	pop	r0
 2f0:	cf 91       	pop	r28
 2f2:	df 91       	pop	r29
 2f4:	1f 91       	pop	r17
 2f6:	0f 91       	pop	r16
 2f8:	ff 90       	pop	r15
 2fa:	df 90       	pop	r13
 2fc:	cf 90       	pop	r12
 2fe:	bf 90       	pop	r11
 300:	af 90       	pop	r10
 302:	08 95       	ret

00000304 <can_initMessageStruct>:
	else return CAN_FAILINIT;
}

void can_initMessageStruct(CanMessage* msg)
{
	memset(msg,0,sizeof(CanMessage));
 304:	fc 01       	movw	r30, r24
 306:	80 e1       	ldi	r24, 0x10	; 16
 308:	df 01       	movw	r26, r30
 30a:	1d 92       	st	X+, r1
 30c:	8a 95       	dec	r24
 30e:	e9 f7       	brne	.-6      	; 0x30a <can_initMessageStruct+0x6>
}
 310:	08 95       	ret

00000312 <can_init>:

uint8_t can_init(uint8_t speedset)
{
	uint8_t res;
	
	res = mcp2515_init(speedset);
 312:	0e 94 1e 04 	call	0x83c	; 0x83c <mcp2515_init>
 316:	81 11       	cpse	r24, r1
 318:	81 e0       	ldi	r24, 0x01	; 1
	
	if (res == MCP2515_OK) return CAN_OK;
	else return CAN_FAILINIT;
}
 31a:	08 95       	ret

0000031c <spi_init>:

/* init as SPI-Master */
void spi_init(void)
{
	// SCK, SS!!, MOSI as outputs
    SPIDDR |= (1 << SPISCK);
 31c:	25 9a       	sbi	0x04, 5	; 4
    SPIDDR |= (1 << SPIMOSI);
 31e:	23 9a       	sbi	0x04, 3	; 4
    SPIDDR |= (1 << SPISS);
 320:	22 9a       	sbi	0x04, 2	; 4
    // MISO as input
	//SPIDDR &= ~(1 << SPIMISO);	// cbi(SPIDDR,SPIMISO);
	// INIT interface, Master, set clock rate fck/128 TODO: check prescaler
	//SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR0)|(1<<SPR1);

    SPIPORT &= ~(1 << SPISCK);
 322:	2d 98       	cbi	0x05, 5	; 5
    SPIPORT &= ~(1 << SPIMOSI);
 324:	2b 98       	cbi	0x05, 3	; 5
    SPIPORT |=  (1 << SPISS);
 326:	2a 9a       	sbi	0x05, 2	; 5

    SPCR |= (1 << MSTR);
 328:	8c b5       	in	r24, 0x2c	; 44
 32a:	80 61       	ori	r24, 0x10	; 16
 32c:	8c bd       	out	0x2c, r24	; 44
    SPCR |= (1 << SPE);
 32e:	8c b5       	in	r24, 0x2c	; 44
 330:	80 64       	ori	r24, 0x40	; 64
 332:	8c bd       	out	0x2c, r24	; 44
}
 334:	08 95       	ret

00000336 <spi_readwrite>:

uint8_t spi_readwrite(uint8_t data)
{
	// set data to send into SPI data register
	SPDR = data;
 336:	8e bd       	out	0x2e, r24	; 46
	// Wait for transmission complete 
	while(!(SPSR & (1<<SPIF)));
 338:	0d b4       	in	r0, 0x2d	; 45
 33a:	07 fe       	sbrs	r0, 7
 33c:	fd cf       	rjmp	.-6      	; 0x338 <spi_readwrite+0x2>
	// return data read from SPI
	return SPDR;
 33e:	8e b5       	in	r24, 0x2e	; 46
}
 340:	08 95       	ret

00000342 <spi_read>:
}

uint8_t spi_readwrite(uint8_t data)
{
	// set data to send into SPI data register
	SPDR = data;
 342:	1e bc       	out	0x2e, r1	; 46
	// Wait for transmission complete 
	while(!(SPSR & (1<<SPIF)));
 344:	0d b4       	in	r0, 0x2d	; 45
 346:	07 fe       	sbrs	r0, 7
 348:	fd cf       	rjmp	.-6      	; 0x344 <spi_read+0x2>
	// return data read from SPI
	return SPDR;
 34a:	8e b5       	in	r24, 0x2e	; 46
}

uint8_t spi_read(void)
{
	return spi_readwrite(SPIDONTCARE);
}
 34c:	08 95       	ret

0000034e <mcp2515_modifyRegister>:
	MCP2515_UNSELECT();
}

void mcp2515_modifyRegister(const uint8_t address, 
	const uint8_t mask, const uint8_t data)
{
 34e:	ff 92       	push	r15
 350:	0f 93       	push	r16
 352:	1f 93       	push	r17
 354:	18 2f       	mov	r17, r24
 356:	06 2f       	mov	r16, r22
 358:	f4 2e       	mov	r15, r20
	MCP2515_SELECT();
 35a:	2a 98       	cbi	0x05, 2	; 5
	spi_readwrite(MCP_BITMOD);
 35c:	85 e0       	ldi	r24, 0x05	; 5
 35e:	0e 94 9b 01 	call	0x336	; 0x336 <spi_readwrite>
	spi_readwrite(address);
 362:	81 2f       	mov	r24, r17
 364:	0e 94 9b 01 	call	0x336	; 0x336 <spi_readwrite>
	spi_readwrite(mask);
 368:	80 2f       	mov	r24, r16
 36a:	0e 94 9b 01 	call	0x336	; 0x336 <spi_readwrite>
	spi_readwrite(data);
 36e:	8f 2d       	mov	r24, r15
 370:	0e 94 9b 01 	call	0x336	; 0x336 <spi_readwrite>
	MCP2515_UNSELECT();
 374:	2a 9a       	sbi	0x05, 2	; 5
}
 376:	1f 91       	pop	r17
 378:	0f 91       	pop	r16
 37a:	ff 90       	pop	r15
 37c:	08 95       	ret

0000037e <mcp2515_start_transmit>:
 */
// Buffer can be MCP_TXBUF_0 MCP_TXBUF_1 or MCP_TXBUF_2
void mcp2515_start_transmit(const uint8_t buffer_sidh_addr)
{
	// TXBnCTRL_addr = TXBnSIDH_addr - 1
    mcp2515_modifyRegister( buffer_sidh_addr-1 , MCP_TXB_TXREQ_M, 
 37e:	81 50       	subi	r24, 0x01	; 1
 380:	68 e0       	ldi	r22, 0x08	; 8
 382:	48 e0       	ldi	r20, 0x08	; 8
 384:	0e 94 a7 01 	call	0x34e	; 0x34e <mcp2515_modifyRegister>
		MCP_TXB_TXREQ_M );
}
 388:	08 95       	ret

0000038a <mcp2515_setRegisterS>:
	MCP2515_UNSELECT();
}

void mcp2515_setRegisterS(const uint8_t address, 
	const uint8_t values[], const uint8_t n)
{
 38a:	ef 92       	push	r14
 38c:	ff 92       	push	r15
 38e:	0f 93       	push	r16
 390:	1f 93       	push	r17
 392:	cf 93       	push	r28
 394:	df 93       	push	r29
 396:	18 2f       	mov	r17, r24
 398:	06 2f       	mov	r16, r22
 39a:	f7 2e       	mov	r15, r23
 39c:	e4 2e       	mov	r14, r20
	uint8_t i;
	
	MCP2515_SELECT();
 39e:	2a 98       	cbi	0x05, 2	; 5
	spi_readwrite(MCP_WRITE);
 3a0:	82 e0       	ldi	r24, 0x02	; 2
 3a2:	0e 94 9b 01 	call	0x336	; 0x336 <spi_readwrite>
	spi_readwrite(address);
 3a6:	81 2f       	mov	r24, r17
 3a8:	0e 94 9b 01 	call	0x336	; 0x336 <spi_readwrite>
 3ac:	20 2f       	mov	r18, r16
 3ae:	3f 2d       	mov	r19, r15
 3b0:	c9 01       	movw	r24, r18
 3b2:	ec 01       	movw	r28, r24
 3b4:	10 e0       	ldi	r17, 0x00	; 0
 3b6:	04 c0       	rjmp	.+8      	; 0x3c0 <mcp2515_setRegisterS+0x36>
	// mcp2515 has auto-increment of address-pointer
	for (i=0; i<n; i++) {
		spi_readwrite(values[i]);
 3b8:	89 91       	ld	r24, Y+
 3ba:	0e 94 9b 01 	call	0x336	; 0x336 <spi_readwrite>
	
	MCP2515_SELECT();
	spi_readwrite(MCP_WRITE);
	spi_readwrite(address);
	// mcp2515 has auto-increment of address-pointer
	for (i=0; i<n; i++) {
 3be:	1f 5f       	subi	r17, 0xFF	; 255
 3c0:	1e 15       	cp	r17, r14
 3c2:	d0 f3       	brcs	.-12     	; 0x3b8 <mcp2515_setRegisterS+0x2e>
		spi_readwrite(values[i]);
	}
	MCP2515_UNSELECT();
 3c4:	2a 9a       	sbi	0x05, 2	; 5
}
 3c6:	df 91       	pop	r29
 3c8:	cf 91       	pop	r28
 3ca:	1f 91       	pop	r17
 3cc:	0f 91       	pop	r16
 3ce:	ff 90       	pop	r15
 3d0:	ef 90       	pop	r14
 3d2:	08 95       	ret

000003d4 <mcp2515_write_can_id>:
}


void mcp2515_write_can_id( const uint8_t mcp_addr, 
	const uint8_t ext, const uint32_t can_id )
{
 3d4:	df 93       	push	r29
 3d6:	cf 93       	push	r28
 3d8:	00 d0       	rcall	.+0      	; 0x3da <mcp2515_write_can_id+0x6>
 3da:	00 d0       	rcall	.+0      	; 0x3dc <mcp2515_write_can_id+0x8>
 3dc:	cd b7       	in	r28, 0x3d	; 61
 3de:	de b7       	in	r29, 0x3e	; 62
 3e0:	78 2f       	mov	r23, r24
    uint16_t canid;
    uint8_t tbufdata[4];
	
    canid = (uint16_t)(can_id & 0x0FFFF);
 3e2:	f9 01       	movw	r30, r18
    
	if ( ext == 1) {
 3e4:	61 30       	cpi	r22, 0x01	; 1
 3e6:	c9 f4       	brne	.+50     	; 0x41a <mcp2515_write_can_id+0x46>
        tbufdata[MCP_EID0] = (uint8_t) (canid & 0xFF);
 3e8:	2c 83       	std	Y+4, r18	; 0x04
        tbufdata[MCP_EID8] = (uint8_t) (canid / 256);
 3ea:	fb 83       	std	Y+3, r31	; 0x03
        canid = (uint16_t)( can_id / 0x10000L );
 3ec:	ca 01       	movw	r24, r20
 3ee:	aa 27       	eor	r26, r26
 3f0:	bb 27       	eor	r27, r27
        tbufdata[MCP_SIDL] = (uint8_t) (canid & 0x03);
        tbufdata[MCP_SIDL] += (uint8_t) ((canid & 0x1C )*8);
 3f2:	9c 01       	movw	r18, r24
 3f4:	2c 71       	andi	r18, 0x1C	; 28
 3f6:	30 70       	andi	r19, 0x00	; 0
 3f8:	43 e0       	ldi	r20, 0x03	; 3
 3fa:	22 0f       	add	r18, r18
 3fc:	33 1f       	adc	r19, r19
 3fe:	4a 95       	dec	r20
 400:	e1 f7       	brne	.-8      	; 0x3fa <mcp2515_write_can_id+0x26>
 402:	48 2f       	mov	r20, r24
 404:	43 70       	andi	r20, 0x03	; 3
 406:	42 0f       	add	r20, r18
        tbufdata[MCP_SIDL] |= MCP_TXB_EXIDE_M;
 408:	48 60       	ori	r20, 0x08	; 8
 40a:	4a 83       	std	Y+2, r20	; 0x02
        tbufdata[MCP_SIDH] = (uint8_t) (canid / 32 );
 40c:	35 e0       	ldi	r19, 0x05	; 5
 40e:	96 95       	lsr	r25
 410:	87 95       	ror	r24
 412:	3a 95       	dec	r19
 414:	e1 f7       	brne	.-8      	; 0x40e <mcp2515_write_can_id+0x3a>
 416:	89 83       	std	Y+1, r24	; 0x01
 418:	11 c0       	rjmp	.+34     	; 0x43c <mcp2515_write_can_id+0x68>
    }
    else {
        tbufdata[MCP_SIDH] = (uint8_t) (canid / 8 );
 41a:	c9 01       	movw	r24, r18
 41c:	23 e0       	ldi	r18, 0x03	; 3
 41e:	96 95       	lsr	r25
 420:	87 95       	ror	r24
 422:	2a 95       	dec	r18
 424:	e1 f7       	brne	.-8      	; 0x41e <mcp2515_write_can_id+0x4a>
 426:	89 83       	std	Y+1, r24	; 0x01
        tbufdata[MCP_SIDL] = (uint8_t) ((canid & 0x07 )*32);
 428:	e7 70       	andi	r30, 0x07	; 7
 42a:	f0 70       	andi	r31, 0x00	; 0
 42c:	85 e0       	ldi	r24, 0x05	; 5
 42e:	ee 0f       	add	r30, r30
 430:	ff 1f       	adc	r31, r31
 432:	8a 95       	dec	r24
 434:	e1 f7       	brne	.-8      	; 0x42e <mcp2515_write_can_id+0x5a>
 436:	ea 83       	std	Y+2, r30	; 0x02
        tbufdata[MCP_EID0] = 0;
 438:	1c 82       	std	Y+4, r1	; 0x04
        tbufdata[MCP_EID8] = 0;
 43a:	1b 82       	std	Y+3, r1	; 0x03
    }
	mcp2515_setRegisterS( mcp_addr, tbufdata, 4 );
 43c:	87 2f       	mov	r24, r23
 43e:	be 01       	movw	r22, r28
 440:	6f 5f       	subi	r22, 0xFF	; 255
 442:	7f 4f       	sbci	r23, 0xFF	; 255
 444:	44 e0       	ldi	r20, 0x04	; 4
 446:	0e 94 c5 01 	call	0x38a	; 0x38a <mcp2515_setRegisterS>
}
 44a:	0f 90       	pop	r0
 44c:	0f 90       	pop	r0
 44e:	0f 90       	pop	r0
 450:	0f 90       	pop	r0
 452:	cf 91       	pop	r28
 454:	df 91       	pop	r29
 456:	08 95       	ret

00000458 <mcp2515_setRegister>:
	}
	MCP2515_UNSELECT();
}

void mcp2515_setRegister(const uint8_t address, const uint8_t value)
{
 458:	0f 93       	push	r16
 45a:	1f 93       	push	r17
 45c:	18 2f       	mov	r17, r24
 45e:	06 2f       	mov	r16, r22
	MCP2515_SELECT();
 460:	2a 98       	cbi	0x05, 2	; 5
	spi_readwrite(MCP_WRITE);
 462:	82 e0       	ldi	r24, 0x02	; 2
 464:	0e 94 9b 01 	call	0x336	; 0x336 <spi_readwrite>
	spi_readwrite(address);
 468:	81 2f       	mov	r24, r17
 46a:	0e 94 9b 01 	call	0x336	; 0x336 <spi_readwrite>
	spi_readwrite(value);
 46e:	80 2f       	mov	r24, r16
 470:	0e 94 9b 01 	call	0x336	; 0x336 <spi_readwrite>
	MCP2515_UNSELECT();
 474:	2a 9a       	sbi	0x05, 2	; 5
}
 476:	1f 91       	pop	r17
 478:	0f 91       	pop	r16
 47a:	08 95       	ret

0000047c <mcp2515_initCANBuffers>:
	
	return res;
}

void mcp2515_initCANBuffers(void)
{
 47c:	1f 93       	push	r17
	uint8_t i, a1, a2, a3;
	
	// TODO: check why this is needed to receive extended 
	//   and standard frames
	// Mark all filter bits as don't care:
    mcp2515_write_can_id(MCP_RXM0SIDH, 0, 0);
 47e:	80 e2       	ldi	r24, 0x20	; 32
 480:	60 e0       	ldi	r22, 0x00	; 0
 482:	20 e0       	ldi	r18, 0x00	; 0
 484:	30 e0       	ldi	r19, 0x00	; 0
 486:	40 e0       	ldi	r20, 0x00	; 0
 488:	50 e0       	ldi	r21, 0x00	; 0
 48a:	0e 94 ea 01 	call	0x3d4	; 0x3d4 <mcp2515_write_can_id>
    mcp2515_write_can_id(MCP_RXM1SIDH, 0, 0);
 48e:	84 e2       	ldi	r24, 0x24	; 36
 490:	60 e0       	ldi	r22, 0x00	; 0
 492:	20 e0       	ldi	r18, 0x00	; 0
 494:	30 e0       	ldi	r19, 0x00	; 0
 496:	40 e0       	ldi	r20, 0x00	; 0
 498:	50 e0       	ldi	r21, 0x00	; 0
 49a:	0e 94 ea 01 	call	0x3d4	; 0x3d4 <mcp2515_write_can_id>
    // Anyway, set all filters to 0:
    mcp2515_write_can_id(MCP_RXF0SIDH, 1, 0); // RXB0: extended 
 49e:	80 e0       	ldi	r24, 0x00	; 0
 4a0:	61 e0       	ldi	r22, 0x01	; 1
 4a2:	20 e0       	ldi	r18, 0x00	; 0
 4a4:	30 e0       	ldi	r19, 0x00	; 0
 4a6:	40 e0       	ldi	r20, 0x00	; 0
 4a8:	50 e0       	ldi	r21, 0x00	; 0
 4aa:	0e 94 ea 01 	call	0x3d4	; 0x3d4 <mcp2515_write_can_id>
    mcp2515_write_can_id(MCP_RXF1SIDH, 0, 0); //       AND standard
 4ae:	84 e0       	ldi	r24, 0x04	; 4
 4b0:	60 e0       	ldi	r22, 0x00	; 0
 4b2:	20 e0       	ldi	r18, 0x00	; 0
 4b4:	30 e0       	ldi	r19, 0x00	; 0
 4b6:	40 e0       	ldi	r20, 0x00	; 0
 4b8:	50 e0       	ldi	r21, 0x00	; 0
 4ba:	0e 94 ea 01 	call	0x3d4	; 0x3d4 <mcp2515_write_can_id>
    mcp2515_write_can_id(MCP_RXF2SIDH, 1, 0); // RXB1: extended 
 4be:	88 e0       	ldi	r24, 0x08	; 8
 4c0:	61 e0       	ldi	r22, 0x01	; 1
 4c2:	20 e0       	ldi	r18, 0x00	; 0
 4c4:	30 e0       	ldi	r19, 0x00	; 0
 4c6:	40 e0       	ldi	r20, 0x00	; 0
 4c8:	50 e0       	ldi	r21, 0x00	; 0
 4ca:	0e 94 ea 01 	call	0x3d4	; 0x3d4 <mcp2515_write_can_id>
    mcp2515_write_can_id(MCP_RXF3SIDH, 0, 0); //       AND standard
 4ce:	80 e1       	ldi	r24, 0x10	; 16
 4d0:	60 e0       	ldi	r22, 0x00	; 0
 4d2:	20 e0       	ldi	r18, 0x00	; 0
 4d4:	30 e0       	ldi	r19, 0x00	; 0
 4d6:	40 e0       	ldi	r20, 0x00	; 0
 4d8:	50 e0       	ldi	r21, 0x00	; 0
 4da:	0e 94 ea 01 	call	0x3d4	; 0x3d4 <mcp2515_write_can_id>
    mcp2515_write_can_id(MCP_RXF4SIDH, 0, 0);
 4de:	84 e1       	ldi	r24, 0x14	; 20
 4e0:	60 e0       	ldi	r22, 0x00	; 0
 4e2:	20 e0       	ldi	r18, 0x00	; 0
 4e4:	30 e0       	ldi	r19, 0x00	; 0
 4e6:	40 e0       	ldi	r20, 0x00	; 0
 4e8:	50 e0       	ldi	r21, 0x00	; 0
 4ea:	0e 94 ea 01 	call	0x3d4	; 0x3d4 <mcp2515_write_can_id>
    mcp2515_write_can_id(MCP_RXF5SIDH, 0, 0);
 4ee:	88 e1       	ldi	r24, 0x18	; 24
 4f0:	60 e0       	ldi	r22, 0x00	; 0
 4f2:	20 e0       	ldi	r18, 0x00	; 0
 4f4:	30 e0       	ldi	r19, 0x00	; 0
 4f6:	40 e0       	ldi	r20, 0x00	; 0
 4f8:	50 e0       	ldi	r21, 0x00	; 0
 4fa:	0e 94 ea 01 	call	0x3d4	; 0x3d4 <mcp2515_write_can_id>
 4fe:	10 e3       	ldi	r17, 0x30	; 48
	// TXBnCTRL -> TXBnD7
    a1 = MCP_TXB0CTRL;
	a2 = MCP_TXB1CTRL;
	a3 = MCP_TXB2CTRL;
    for (i = 0; i < 14; i++) { // in-buffer loop
		mcp2515_setRegister(a1, 0);
 500:	81 2f       	mov	r24, r17
 502:	60 e0       	ldi	r22, 0x00	; 0
 504:	0e 94 2c 02 	call	0x458	; 0x458 <mcp2515_setRegister>
		mcp2515_setRegister(a2, 0);
 508:	81 2f       	mov	r24, r17
 50a:	80 5f       	subi	r24, 0xF0	; 240
 50c:	60 e0       	ldi	r22, 0x00	; 0
 50e:	0e 94 2c 02 	call	0x458	; 0x458 <mcp2515_setRegister>
		mcp2515_setRegister(a3, 0);
 512:	81 2f       	mov	r24, r17
 514:	80 5e       	subi	r24, 0xE0	; 224
 516:	60 e0       	ldi	r22, 0x00	; 0
 518:	0e 94 2c 02 	call	0x458	; 0x458 <mcp2515_setRegister>
        a1++;
 51c:	1f 5f       	subi	r17, 0xFF	; 255
	// Clear, deactivate the three transmit buffers
	// TXBnCTRL -> TXBnD7
    a1 = MCP_TXB0CTRL;
	a2 = MCP_TXB1CTRL;
	a3 = MCP_TXB2CTRL;
    for (i = 0; i < 14; i++) { // in-buffer loop
 51e:	1e 33       	cpi	r17, 0x3E	; 62
 520:	79 f7       	brne	.-34     	; 0x500 <__stack+0x1>
		a2++;
		a3++;
    }
	
    // and clear, deactivate the two receive buffers.
    mcp2515_setRegister(MCP_RXB0CTRL, 0);
 522:	80 e6       	ldi	r24, 0x60	; 96
 524:	60 e0       	ldi	r22, 0x00	; 0
 526:	0e 94 2c 02 	call	0x458	; 0x458 <mcp2515_setRegister>
    mcp2515_setRegister(MCP_RXB1CTRL, 0);
 52a:	80 e7       	ldi	r24, 0x70	; 112
 52c:	60 e0       	ldi	r22, 0x00	; 0
 52e:	0e 94 2c 02 	call	0x458	; 0x458 <mcp2515_setRegister>
}
 532:	1f 91       	pop	r17
 534:	08 95       	ret

00000536 <mcp2515_write_canMsg>:
}

// Buffer can be MCP_TXBUF_0 MCP_TXBUF_1 or MCP_TXBUF_2
void mcp2515_write_canMsg( const uint8_t buffer_sidh_addr, 
	const CanMessage* msg)
{
 536:	ef 92       	push	r14
 538:	ff 92       	push	r15
 53a:	0f 93       	push	r16
 53c:	1f 93       	push	r17
 53e:	e8 2e       	mov	r14, r24
 540:	8b 01       	movw	r16, r22
    uint8_t mcp_addr, dlc;

	mcp_addr = buffer_sidh_addr;
	dlc = msg->dlc;
 542:	fb 01       	movw	r30, r22
 544:	f5 80       	ldd	r15, Z+5	; 0x05
	
    mcp2515_setRegisterS(mcp_addr+5, &(msg->dta[0]), dlc );  // write data bytes
 546:	6a 5f       	subi	r22, 0xFA	; 250
 548:	7f 4f       	sbci	r23, 0xFF	; 255
 54a:	8b 5f       	subi	r24, 0xFB	; 251
 54c:	4f 2d       	mov	r20, r15
 54e:	0e 94 c5 01 	call	0x38a	; 0x38a <mcp2515_setRegisterS>
    mcp2515_write_can_id( mcp_addr, msg->extended_identifier,
 552:	f8 01       	movw	r30, r16
 554:	21 81       	ldd	r18, Z+1	; 0x01
 556:	32 81       	ldd	r19, Z+2	; 0x02
 558:	43 81       	ldd	r20, Z+3	; 0x03
 55a:	54 81       	ldd	r21, Z+4	; 0x04
 55c:	8e 2d       	mov	r24, r14
 55e:	60 81       	ld	r22, Z
 560:	0e 94 ea 01 	call	0x3d4	; 0x3d4 <mcp2515_write_can_id>
		msg->identifier );  // write CAN id
    if ( msg->rtr == 1)  dlc |= MCP_RTR_MASK;  // if RTR set bit in byte
 564:	f8 01       	movw	r30, r16
 566:	86 85       	ldd	r24, Z+14	; 0x0e
 568:	81 30       	cpi	r24, 0x01	; 1
 56a:	11 f4       	brne	.+4      	; 0x570 <mcp2515_write_canMsg+0x3a>
 56c:	f0 e4       	ldi	r31, 0x40	; 64
 56e:	ff 2a       	or	r15, r31
    mcp2515_setRegister( (mcp_addr+4), dlc );  // write the RTR and DLC
 570:	8e 2d       	mov	r24, r14
 572:	8c 5f       	subi	r24, 0xFC	; 252
 574:	6f 2d       	mov	r22, r15
 576:	0e 94 2c 02 	call	0x458	; 0x458 <mcp2515_setRegister>
}
 57a:	1f 91       	pop	r17
 57c:	0f 91       	pop	r16
 57e:	ff 90       	pop	r15
 580:	ef 90       	pop	r14
 582:	08 95       	ret

00000584 <mcp2515_configRate>:
	}
}


uint8_t mcp2515_configRate(const uint8_t canSpeed)
{
 584:	0f 93       	push	r16
 586:	1f 93       	push	r17
	uint8_t set, cfg1, cfg2, cfg3;
	
	set = 0;
	
	switch (canSpeed) {
 588:	81 30       	cpi	r24, 0x01	; 1
 58a:	21 f0       	breq	.+8      	; 0x594 <mcp2515_configRate+0x10>
 58c:	82 30       	cpi	r24, 0x02	; 2
 58e:	31 f0       	breq	.+12     	; 0x59c <mcp2515_configRate+0x18>
 590:	81 e0       	ldi	r24, 0x01	; 1
 592:	13 c0       	rjmp	.+38     	; 0x5ba <mcp2515_configRate+0x36>
 594:	64 e0       	ldi	r22, 0x04	; 4
 596:	1a eb       	ldi	r17, 0xBA	; 186
 598:	07 e0       	ldi	r16, 0x07	; 7
 59a:	03 c0       	rjmp	.+6      	; 0x5a2 <mcp2515_configRate+0x1e>
 59c:	61 e0       	ldi	r22, 0x01	; 1
 59e:	19 e8       	ldi	r17, 0x89	; 137
 5a0:	02 e0       	ldi	r16, 0x02	; 2
			set = 0;
			break;
	}
	
	if (set) {
		mcp2515_setRegister(MCP_CNF1, cfg1);
 5a2:	8a e2       	ldi	r24, 0x2A	; 42
 5a4:	0e 94 2c 02 	call	0x458	; 0x458 <mcp2515_setRegister>
		mcp2515_setRegister(MCP_CNF2, cfg2);
 5a8:	89 e2       	ldi	r24, 0x29	; 41
 5aa:	61 2f       	mov	r22, r17
 5ac:	0e 94 2c 02 	call	0x458	; 0x458 <mcp2515_setRegister>
		mcp2515_setRegister(MCP_CNF3, cfg3);
 5b0:	88 e2       	ldi	r24, 0x28	; 40
 5b2:	60 2f       	mov	r22, r16
 5b4:	0e 94 2c 02 	call	0x458	; 0x458 <mcp2515_setRegister>
 5b8:	80 e0       	ldi	r24, 0x00	; 0
		return MCP2515_OK;
	}
	else {
		return MCP2515_FAIL;
	}
} 
 5ba:	1f 91       	pop	r17
 5bc:	0f 91       	pop	r16
 5be:	08 95       	ret

000005c0 <mcp2515_readXXStatus_helper>:

static uint8_t mcp2515_readXXStatus_helper(const uint8_t cmd)
{
	uint8_t i;
	
	MCP2515_SELECT();
 5c0:	2a 98       	cbi	0x05, 2	; 5
	spi_readwrite(cmd);
 5c2:	0e 94 9b 01 	call	0x336	; 0x336 <spi_readwrite>
	i = spi_read();
 5c6:	0e 94 a1 01 	call	0x342	; 0x342 <spi_read>
	MCP2515_UNSELECT();
 5ca:	2a 9a       	sbi	0x05, 2	; 5
	
	return i;
}
 5cc:	08 95       	ret

000005ce <mcp2515_RXStatus>:
	return mcp2515_readXXStatus_helper(MCP_READ_STATUS);
}

uint8_t mcp2515_RXStatus(void)
{
	return mcp2515_readXXStatus_helper(MCP_RX_STATUS);
 5ce:	80 eb       	ldi	r24, 0xB0	; 176
 5d0:	0e 94 e0 02 	call	0x5c0	; 0x5c0 <mcp2515_readXXStatus_helper>
}
 5d4:	08 95       	ret

000005d6 <mcp2515_readStatus>:
	return i;
}
	
uint8_t mcp2515_readStatus(void)
{
	return mcp2515_readXXStatus_helper(MCP_READ_STATUS);
 5d6:	80 ea       	ldi	r24, 0xA0	; 160
 5d8:	0e 94 e0 02 	call	0x5c0	; 0x5c0 <mcp2515_readXXStatus_helper>
}
 5dc:	08 95       	ret

000005de <mcp2515_readRegisterS>:
	return ret;
}

void mcp2515_readRegisterS(const uint8_t address, 
	uint8_t values[], const uint8_t n)
{
 5de:	ef 92       	push	r14
 5e0:	ff 92       	push	r15
 5e2:	0f 93       	push	r16
 5e4:	1f 93       	push	r17
 5e6:	cf 93       	push	r28
 5e8:	df 93       	push	r29
 5ea:	18 2f       	mov	r17, r24
 5ec:	06 2f       	mov	r16, r22
 5ee:	f7 2e       	mov	r15, r23
 5f0:	e4 2e       	mov	r14, r20
	uint8_t i;
	
	MCP2515_SELECT();
 5f2:	2a 98       	cbi	0x05, 2	; 5
	spi_readwrite(MCP_READ);
 5f4:	83 e0       	ldi	r24, 0x03	; 3
 5f6:	0e 94 9b 01 	call	0x336	; 0x336 <spi_readwrite>
	spi_readwrite(address);
 5fa:	81 2f       	mov	r24, r17
 5fc:	0e 94 9b 01 	call	0x336	; 0x336 <spi_readwrite>
 600:	20 2f       	mov	r18, r16
 602:	3f 2d       	mov	r19, r15
 604:	c9 01       	movw	r24, r18
 606:	ec 01       	movw	r28, r24
 608:	10 e0       	ldi	r17, 0x00	; 0
 60a:	04 c0       	rjmp	.+8      	; 0x614 <mcp2515_readRegisterS+0x36>
	// mcp2515 has auto-increment of address-pointer
	for (i=0; i<n; i++) {
		values[i] = spi_read();
 60c:	0e 94 a1 01 	call	0x342	; 0x342 <spi_read>
 610:	89 93       	st	Y+, r24
	
	MCP2515_SELECT();
	spi_readwrite(MCP_READ);
	spi_readwrite(address);
	// mcp2515 has auto-increment of address-pointer
	for (i=0; i<n; i++) {
 612:	1f 5f       	subi	r17, 0xFF	; 255
 614:	1e 15       	cp	r17, r14
 616:	d0 f3       	brcs	.-12     	; 0x60c <mcp2515_readRegisterS+0x2e>
		values[i] = spi_read();
	}
	MCP2515_UNSELECT();
 618:	2a 9a       	sbi	0x05, 2	; 5
}
 61a:	df 91       	pop	r29
 61c:	cf 91       	pop	r28
 61e:	1f 91       	pop	r17
 620:	0f 91       	pop	r16
 622:	ff 90       	pop	r15
 624:	ef 90       	pop	r14
 626:	08 95       	ret

00000628 <mcp2515_read_can_id>:

// ---

void mcp2515_read_can_id( const uint8_t mcp_addr, 
	uint8_t* ext, uint32_t* can_id )
{
 628:	ef 92       	push	r14
 62a:	ff 92       	push	r15
 62c:	0f 93       	push	r16
 62e:	1f 93       	push	r17
 630:	df 93       	push	r29
 632:	cf 93       	push	r28
 634:	00 d0       	rcall	.+0      	; 0x636 <mcp2515_read_can_id+0xe>
 636:	00 d0       	rcall	.+0      	; 0x638 <mcp2515_read_can_id+0x10>
 638:	cd b7       	in	r28, 0x3d	; 61
 63a:	de b7       	in	r29, 0x3e	; 62
 63c:	7b 01       	movw	r14, r22
 63e:	8a 01       	movw	r16, r20
    uint8_t tbufdata[4];
	
    *ext = 0;
 640:	fb 01       	movw	r30, r22
 642:	10 82       	st	Z, r1
    *can_id = 0;
 644:	fa 01       	movw	r30, r20
 646:	10 82       	st	Z, r1
 648:	11 82       	std	Z+1, r1	; 0x01
 64a:	12 82       	std	Z+2, r1	; 0x02
 64c:	13 82       	std	Z+3, r1	; 0x03
    
	mcp2515_readRegisterS( mcp_addr, tbufdata, 4 );
 64e:	be 01       	movw	r22, r28
 650:	6f 5f       	subi	r22, 0xFF	; 255
 652:	7f 4f       	sbci	r23, 0xFF	; 255
 654:	44 e0       	ldi	r20, 0x04	; 4
 656:	0e 94 ef 02 	call	0x5de	; 0x5de <mcp2515_readRegisterS>
    
	*can_id = (tbufdata[MCP_SIDH]<<3) + (tbufdata[MCP_SIDL]>>5);
 65a:	3a 81       	ldd	r19, Y+2	; 0x02
 65c:	23 2f       	mov	r18, r19
 65e:	22 95       	swap	r18
 660:	26 95       	lsr	r18
 662:	27 70       	andi	r18, 0x07	; 7
 664:	89 81       	ldd	r24, Y+1	; 0x01
 666:	90 e0       	ldi	r25, 0x00	; 0
 668:	43 e0       	ldi	r20, 0x03	; 3
 66a:	88 0f       	add	r24, r24
 66c:	99 1f       	adc	r25, r25
 66e:	4a 95       	dec	r20
 670:	e1 f7       	brne	.-8      	; 0x66a <mcp2515_read_can_id+0x42>
 672:	82 0f       	add	r24, r18
 674:	91 1d       	adc	r25, r1
 676:	ac 01       	movw	r20, r24
 678:	66 27       	eor	r22, r22
 67a:	57 fd       	sbrc	r21, 7
 67c:	60 95       	com	r22
 67e:	76 2f       	mov	r23, r22
 680:	f8 01       	movw	r30, r16
 682:	40 83       	st	Z, r20
 684:	51 83       	std	Z+1, r21	; 0x01
 686:	62 83       	std	Z+2, r22	; 0x02
 688:	73 83       	std	Z+3, r23	; 0x03
	
    if ( (tbufdata[MCP_SIDL] & MCP_TXB_EXIDE_M) ==  MCP_TXB_EXIDE_M ) {
 68a:	33 ff       	sbrs	r19, 3
 68c:	25 c0       	rjmp	.+74     	; 0x6d8 <mcp2515_read_can_id+0xb0>
		// extended id
        *can_id = (*can_id<<2) + (tbufdata[MCP_SIDL] & 0x03);
        *can_id <<= 16;
 68e:	b2 e0       	ldi	r27, 0x02	; 2
 690:	44 0f       	add	r20, r20
 692:	55 1f       	adc	r21, r21
 694:	66 1f       	adc	r22, r22
 696:	77 1f       	adc	r23, r23
 698:	ba 95       	dec	r27
 69a:	d1 f7       	brne	.-12     	; 0x690 <mcp2515_read_can_id+0x68>
 69c:	33 70       	andi	r19, 0x03	; 3
 69e:	43 0f       	add	r20, r19
 6a0:	51 1d       	adc	r21, r1
 6a2:	61 1d       	adc	r22, r1
 6a4:	71 1d       	adc	r23, r1
 6a6:	ba 01       	movw	r22, r20
 6a8:	55 27       	eor	r21, r21
 6aa:	44 27       	eor	r20, r20
        *can_id = *can_id +(tbufdata[MCP_EID8]<<8) + tbufdata[MCP_EID0];
 6ac:	9b 81       	ldd	r25, Y+3	; 0x03
 6ae:	80 e0       	ldi	r24, 0x00	; 0
 6b0:	aa 27       	eor	r26, r26
 6b2:	97 fd       	sbrc	r25, 7
 6b4:	a0 95       	com	r26
 6b6:	ba 2f       	mov	r27, r26
 6b8:	2c 81       	ldd	r18, Y+4	; 0x04
 6ba:	82 0f       	add	r24, r18
 6bc:	91 1d       	adc	r25, r1
 6be:	a1 1d       	adc	r26, r1
 6c0:	b1 1d       	adc	r27, r1
 6c2:	84 0f       	add	r24, r20
 6c4:	95 1f       	adc	r25, r21
 6c6:	a6 1f       	adc	r26, r22
 6c8:	b7 1f       	adc	r27, r23
 6ca:	80 83       	st	Z, r24
 6cc:	91 83       	std	Z+1, r25	; 0x01
 6ce:	a2 83       	std	Z+2, r26	; 0x02
 6d0:	b3 83       	std	Z+3, r27	; 0x03
        *ext = 1;
 6d2:	81 e0       	ldi	r24, 0x01	; 1
 6d4:	f7 01       	movw	r30, r14
 6d6:	80 83       	st	Z, r24
    }
}
 6d8:	0f 90       	pop	r0
 6da:	0f 90       	pop	r0
 6dc:	0f 90       	pop	r0
 6de:	0f 90       	pop	r0
 6e0:	cf 91       	pop	r28
 6e2:	df 91       	pop	r29
 6e4:	1f 91       	pop	r17
 6e6:	0f 91       	pop	r16
 6e8:	ff 90       	pop	r15
 6ea:	ef 90       	pop	r14
 6ec:	08 95       	ret

000006ee <mcp2515_readRegister>:
	MCP2515_UNSELECT();
	delay_ms(10); // rough - but > 128 MCP clock-cycles
}

uint8_t mcp2515_readRegister(const uint8_t address)
{
 6ee:	1f 93       	push	r17
 6f0:	18 2f       	mov	r17, r24
	uint8_t ret;
	
	MCP2515_SELECT();
 6f2:	2a 98       	cbi	0x05, 2	; 5
	spi_readwrite(MCP_READ);
 6f4:	83 e0       	ldi	r24, 0x03	; 3
 6f6:	0e 94 9b 01 	call	0x336	; 0x336 <spi_readwrite>
	spi_readwrite(address);
 6fa:	81 2f       	mov	r24, r17
 6fc:	0e 94 9b 01 	call	0x336	; 0x336 <spi_readwrite>
	ret = spi_read();
 700:	0e 94 a1 01 	call	0x342	; 0x342 <spi_read>
	MCP2515_UNSELECT();
 704:	2a 9a       	sbi	0x05, 2	; 5
	
	return ret;
}
 706:	1f 91       	pop	r17
 708:	08 95       	ret

0000070a <mcp2515_set_config_mode>:

#define CANCTRL_REQOP_MASK          0xe0
#define CANCTRL_REQOP_CONF          0x80

uint8_t mcp2515_set_config_mode() {
    uint8_t cctrl = mcp2515_readRegister(MCP_CANCTRL);
 70a:	8f e0       	ldi	r24, 0x0F	; 15
 70c:	0e 94 77 03 	call	0x6ee	; 0x6ee <mcp2515_readRegister>

    cctrl |=  (1 << 7);
 710:	68 2f       	mov	r22, r24
 712:	60 68       	ori	r22, 0x80	; 128
    cctrl &= ~(1 << 6);
    cctrl &= ~(1 << 5);

    mcp2515_setRegister(MCP_CANCTRL, cctrl);
 714:	6f 79       	andi	r22, 0x9F	; 159
 716:	8f e0       	ldi	r24, 0x0F	; 15
 718:	0e 94 2c 02 	call	0x458	; 0x458 <mcp2515_setRegister>

    // Read to verify setted bits
    cctrl = mcp2515_readRegister(MCP_CANCTRL);
 71c:	8f e0       	ldi	r24, 0x0F	; 15
 71e:	0e 94 77 03 	call	0x6ee	; 0x6ee <mcp2515_readRegister>
 722:	90 e0       	ldi	r25, 0x00	; 0
 724:	80 7e       	andi	r24, 0xE0	; 224
 726:	80 38       	cpi	r24, 0x80	; 128
 728:	09 f0       	breq	.+2      	; 0x72c <mcp2515_set_config_mode+0x22>
 72a:	91 e0       	ldi	r25, 0x01	; 1
    if ( (cctrl & CANCTRL_REQOP_MASK) == CANCTRL_REQOP_CONF ) {
        return MCP2515_OK; 
	} else {
        return MCP2515_FAIL;
	}
}
 72c:	89 2f       	mov	r24, r25
 72e:	08 95       	ret

00000730 <mcp2515_getNextFreeTXBuf>:
    mcp2515_modifyRegister( buffer_sidh_addr-1 , MCP_TXB_TXREQ_M, 
		MCP_TXB_TXREQ_M );
}

uint8_t mcp2515_getNextFreeTXBuf(uint8_t *txbuf_n)
{
 730:	af 92       	push	r10
 732:	bf 92       	push	r11
 734:	cf 92       	push	r12
 736:	df 92       	push	r13
 738:	ff 92       	push	r15
 73a:	0f 93       	push	r16
 73c:	1f 93       	push	r17
 73e:	df 93       	push	r29
 740:	cf 93       	push	r28
 742:	00 d0       	rcall	.+0      	; 0x744 <mcp2515_getNextFreeTXBuf+0x14>
 744:	0f 92       	push	r0
 746:	cd b7       	in	r28, 0x3d	; 61
 748:	de b7       	in	r29, 0x3e	; 62
 74a:	6c 01       	movw	r12, r24
	uint8_t res, i, ctrlval;
	uint8_t ctrlregs[MCP_N_TXBUFFERS] = { MCP_TXB0CTRL, MCP_TXB1CTRL, MCP_TXB2CTRL };
 74c:	de 01       	movw	r26, r28
 74e:	11 96       	adiw	r26, 0x01	; 1
 750:	e1 e0       	ldi	r30, 0x01	; 1
 752:	f1 e0       	ldi	r31, 0x01	; 1
 754:	83 e0       	ldi	r24, 0x03	; 3
 756:	01 90       	ld	r0, Z+
 758:	0d 92       	st	X+, r0
 75a:	81 50       	subi	r24, 0x01	; 1
 75c:	e1 f7       	brne	.-8      	; 0x756 <mcp2515_getNextFreeTXBuf+0x26>
	
	res = MCP_ALLTXBUSY;
	*txbuf_n = 0x00;
 75e:	f6 01       	movw	r30, r12
 760:	10 82       	st	Z, r1
 762:	8e 01       	movw	r16, r28
 764:	0f 5f       	subi	r16, 0xFF	; 255
 766:	1f 4f       	sbci	r17, 0xFF	; 255
	
	// check all 3 TX-Buffers
	for (i=0; i<MCP_N_TXBUFFERS; i++) {
 768:	54 e0       	ldi	r21, 0x04	; 4
 76a:	a5 2e       	mov	r10, r21
 76c:	b1 2c       	mov	r11, r1
 76e:	ac 0e       	add	r10, r28
 770:	bd 1e       	adc	r11, r29
		ctrlval = mcp2515_readRegister( ctrlregs[i] );
 772:	f8 01       	movw	r30, r16
 774:	f0 80       	ld	r15, Z
 776:	8f 2d       	mov	r24, r15
 778:	0e 94 77 03 	call	0x6ee	; 0x6ee <mcp2515_readRegister>
		if ( (ctrlval & MCP_TXB_TXREQ_M) == 0 ) {
 77c:	83 fd       	sbrc	r24, 3
 77e:	05 c0       	rjmp	.+10     	; 0x78a <mcp2515_getNextFreeTXBuf+0x5a>
#if (MCPDEBUG_TXBUF)
			Debug_ByteToUart_P("Selected TX-Buffer", i+1);
#endif
			*txbuf_n = ctrlregs[i]+1; // return SIDH-address of Buffer
 780:	f3 94       	inc	r15
 782:	f6 01       	movw	r30, r12
 784:	f0 82       	st	Z, r15
 786:	80 e0       	ldi	r24, 0x00	; 0
 788:	06 c0       	rjmp	.+12     	; 0x796 <mcp2515_getNextFreeTXBuf+0x66>
			res = MCP2515_OK;
			return res; /* ! function exit */
 78a:	0f 5f       	subi	r16, 0xFF	; 255
 78c:	1f 4f       	sbci	r17, 0xFF	; 255
	
	res = MCP_ALLTXBUSY;
	*txbuf_n = 0x00;
	
	// check all 3 TX-Buffers
	for (i=0; i<MCP_N_TXBUFFERS; i++) {
 78e:	0a 15       	cp	r16, r10
 790:	1b 05       	cpc	r17, r11
 792:	79 f7       	brne	.-34     	; 0x772 <mcp2515_getNextFreeTXBuf+0x42>
 794:	82 e0       	ldi	r24, 0x02	; 2
			return res; /* ! function exit */
		}
	}
	
	return res;
}
 796:	0f 90       	pop	r0
 798:	0f 90       	pop	r0
 79a:	0f 90       	pop	r0
 79c:	cf 91       	pop	r28
 79e:	df 91       	pop	r29
 7a0:	1f 91       	pop	r17
 7a2:	0f 91       	pop	r16
 7a4:	ff 90       	pop	r15
 7a6:	df 90       	pop	r13
 7a8:	cf 90       	pop	r12
 7aa:	bf 90       	pop	r11
 7ac:	af 90       	pop	r10
 7ae:	08 95       	ret

000007b0 <mcp2515_read_canMsg>:
}

// Buffer can be MCP_RXBUF_0 or MCP_RXBUF_1
void mcp2515_read_canMsg( const uint8_t buffer_sidh_addr,
	CanMessage* msg)
{
 7b0:	0f 93       	push	r16
 7b2:	1f 93       	push	r17
 7b4:	cf 93       	push	r28
 7b6:	df 93       	push	r29
 7b8:	08 2f       	mov	r16, r24
 7ba:	eb 01       	movw	r28, r22

    uint8_t mcp_addr, ctrl;

	mcp_addr = buffer_sidh_addr;
	
    mcp2515_read_can_id( mcp_addr, &(msg->extended_identifier), 
 7bc:	ab 01       	movw	r20, r22
 7be:	4f 5f       	subi	r20, 0xFF	; 255
 7c0:	5f 4f       	sbci	r21, 0xFF	; 255
 7c2:	0e 94 14 03 	call	0x628	; 0x628 <mcp2515_read_can_id>
		&(msg->identifier) );
    
	ctrl = mcp2515_readRegister( mcp_addr-1 );
 7c6:	80 2f       	mov	r24, r16
 7c8:	81 50       	subi	r24, 0x01	; 1
 7ca:	0e 94 77 03 	call	0x6ee	; 0x6ee <mcp2515_readRegister>
 7ce:	18 2f       	mov	r17, r24
    msg->dlc = mcp2515_readRegister( mcp_addr+4 );
 7d0:	80 2f       	mov	r24, r16
 7d2:	8c 5f       	subi	r24, 0xFC	; 252
 7d4:	0e 94 77 03 	call	0x6ee	; 0x6ee <mcp2515_readRegister>
 7d8:	8d 83       	std	Y+5, r24	; 0x05
    
	if (/*(*dlc & RTR_MASK) || */(ctrl & 0x08)) {
 7da:	13 ff       	sbrs	r17, 3
 7dc:	03 c0       	rjmp	.+6      	; 0x7e4 <mcp2515_read_canMsg+0x34>
        msg->rtr = 1;
 7de:	81 e0       	ldi	r24, 0x01	; 1
 7e0:	8e 87       	std	Y+14, r24	; 0x0e
 7e2:	01 c0       	rjmp	.+2      	; 0x7e6 <mcp2515_read_canMsg+0x36>
    } else {
        msg->rtr = 0;
 7e4:	1e 86       	std	Y+14, r1	; 0x0e
    }
    
	msg->dlc &= MCP_DLC_MASK;
 7e6:	4d 81       	ldd	r20, Y+5	; 0x05
 7e8:	4f 70       	andi	r20, 0x0F	; 15
 7ea:	4d 83       	std	Y+5, r20	; 0x05
    mcp2515_readRegisterS( mcp_addr+5, &(msg->dta[0]), msg->dlc );
 7ec:	26 96       	adiw	r28, 0x06	; 6
 7ee:	80 2f       	mov	r24, r16
 7f0:	8b 5f       	subi	r24, 0xFB	; 251
 7f2:	be 01       	movw	r22, r28
 7f4:	0e 94 ef 02 	call	0x5de	; 0x5de <mcp2515_readRegisterS>
}
 7f8:	df 91       	pop	r29
 7fa:	cf 91       	pop	r28
 7fc:	1f 91       	pop	r17
 7fe:	0f 91       	pop	r16
 800:	08 95       	ret

00000802 <mcp2515_setCANCTRL_Mode>:
{
	return mcp2515_readXXStatus_helper(MCP_RX_STATUS);
}

uint8_t mcp2515_setCANCTRL_Mode(const uint8_t newmode)
{
 802:	1f 93       	push	r17
 804:	18 2f       	mov	r17, r24
	uint8_t i;
	
	mcp2515_modifyRegister(MCP_CANCTRL, MODE_MASK, newmode);
 806:	8f e0       	ldi	r24, 0x0F	; 15
 808:	60 ee       	ldi	r22, 0xE0	; 224
 80a:	41 2f       	mov	r20, r17
 80c:	0e 94 a7 01 	call	0x34e	; 0x34e <mcp2515_modifyRegister>
	
	// verify as advised in datasheet
	i = mcp2515_readRegister(MCP_CANCTRL);
 810:	8f e0       	ldi	r24, 0x0F	; 15
 812:	0e 94 77 03 	call	0x6ee	; 0x6ee <mcp2515_readRegister>
 816:	90 e0       	ldi	r25, 0x00	; 0
 818:	80 7e       	andi	r24, 0xE0	; 224
 81a:	81 13       	cpse	r24, r17
 81c:	91 e0       	ldi	r25, 0x01	; 1
		return MCP2515_OK; 
	}
	else {
		return MCP2515_FAIL;
	}
}
 81e:	89 2f       	mov	r24, r25
 820:	1f 91       	pop	r17
 822:	08 95       	ret

00000824 <mcp2515_reset>:
#include "termio.h"
#endif

void mcp2515_reset(void)
{
	MCP2515_SELECT();
 824:	2a 98       	cbi	0x05, 2	; 5
	spi_readwrite(MCP_RESET);
 826:	80 ec       	ldi	r24, 0xC0	; 192
 828:	0e 94 9b 01 	call	0x336	; 0x336 <spi_readwrite>
	MCP2515_UNSELECT();
 82c:	2a 9a       	sbi	0x05, 2	; 5
	delay_ms(10); // rough - but > 128 MCP clock-cycles
 82e:	64 e2       	ldi	r22, 0x24	; 36
 830:	78 e6       	ldi	r23, 0x68	; 104
 832:	80 e0       	ldi	r24, 0x00	; 0
 834:	90 e0       	ldi	r25, 0x00	; 0
 836:	0e 94 61 04 	call	0x8c2	; 0x8c2 <delayloop32>
}
 83a:	08 95       	ret

0000083c <mcp2515_init>:

// ---

#include <util/delay.h>
uint8_t mcp2515_init(const uint8_t canSpeed)
{
 83c:	1f 93       	push	r17
 83e:	18 2f       	mov	r17, r24
	uint8_t res;
	
	//MCP2515_UNSELECT();
	//MCP_CS_DDR |= ( 1 << MCP_CS_BIT );
	
	mcp2515_reset();
 840:	0e 94 12 04 	call	0x824	; 0x824 <mcp2515_reset>
    MCP2515_SELECT();
 844:	2a 98       	cbi	0x05, 2	; 5
	//res = mcp2515_setCANCTRL_Mode(MODE_CONFIG);
#endif
	
	//if ( res == MCP2515_FAIL ) return res; //return MCP2515_OK;   // function exit on error 
	
	res = mcp2515_configRate(canSpeed);
 846:	81 2f       	mov	r24, r17
 848:	0e 94 c2 02 	call	0x584	; 0x584 <mcp2515_configRate>
 84c:	18 2f       	mov	r17, r24
	
	if ( res == MCP2515_OK ) {
 84e:	88 23       	and	r24, r24
 850:	61 f4       	brne	.+24     	; 0x86a <mcp2515_init+0x2e>
		mcp2515_initCANBuffers();
 852:	0e 94 3e 02 	call	0x47c	; 0x47c <mcp2515_initCANBuffers>
			MCP_RXB_RX_ANY);
#else
		// enable both receive-buffers to receive messages
		// with std. and ext. identifiers
		// and enable rollover
		mcp2515_modifyRegister(MCP_RXB0CTRL, 
 856:	80 e6       	ldi	r24, 0x60	; 96
 858:	64 e6       	ldi	r22, 0x64	; 100
 85a:	44 e0       	ldi	r20, 0x04	; 4
 85c:	0e 94 a7 01 	call	0x34e	; 0x34e <mcp2515_modifyRegister>
			MCP_RXB_RX_MASK | MCP_RXB_BUKT_MASK, 
			MCP_RXB_RX_STDEXT | MCP_RXB_BUKT_MASK );
		mcp2515_modifyRegister(MCP_RXB1CTRL, MCP_RXB_RX_MASK, 
 860:	80 e7       	ldi	r24, 0x70	; 112
 862:	60 e6       	ldi	r22, 0x60	; 96
 864:	40 e0       	ldi	r20, 0x00	; 0
 866:	0e 94 a7 01 	call	0x34e	; 0x34e <mcp2515_modifyRegister>
			MCP_RXB_RX_STDEXT);
#endif
	}
    MCP2515_UNSELECT();
 86a:	2a 9a       	sbi	0x05, 2	; 5
 86c:	88 ee       	ldi	r24, 0xE8	; 232
 86e:	93 e0       	ldi	r25, 0x03	; 3
 870:	20 e9       	ldi	r18, 0x90	; 144
 872:	31 e0       	ldi	r19, 0x01	; 1
 874:	f9 01       	movw	r30, r18
 876:	31 97       	sbiw	r30, 0x01	; 1
 878:	f1 f7       	brne	.-4      	; 0x876 <mcp2515_init+0x3a>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 87a:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 87c:	d9 f7       	brne	.-10     	; 0x874 <mcp2515_init+0x38>
    _delay_ms(100);

	return res;
}
 87e:	81 2f       	mov	r24, r17
 880:	1f 91       	pop	r17
 882:	08 95       	ret

00000884 <timebase_init>:
	TCNT1 = TIMEBASE_RELOAD;
}
*/
void timebase_init(void)
{
	TCCR0 = (1<<CS01) | (1<<CS00); // prescaler: 64
 884:	83 e0       	ldi	r24, 0x03	; 3
 886:	83 bf       	out	0x33, r24	; 51
	TCNT0 = TIMEBASE_RELOAD; // set initial reload-value
 888:	86 e0       	ldi	r24, 0x06	; 6
 88a:	82 bf       	out	0x32, r24	; 50
	TIFR  |= (1<<TOV0);  // clear overflow int.
 88c:	88 b7       	in	r24, 0x38	; 56
 88e:	81 60       	ori	r24, 0x01	; 1
 890:	88 bf       	out	0x38, r24	; 56
	TIMSK |= (1<<TOIE0); // enable overflow-interrupt
 892:	89 b7       	in	r24, 0x39	; 57
 894:	81 60       	ori	r24, 0x01	; 1
 896:	89 bf       	out	0x39, r24	; 57
}
 898:	08 95       	ret

0000089a <timebase_actTime>:
uint16_t timebase_actTime(void)
{
	uint8_t sreg;
	uint16_t res;
	
	sreg=SREG;
 89a:	8f b7       	in	r24, 0x3f	; 63
	cli();
 89c:	f8 94       	cli

	res = gMilliSecTick;
 89e:	20 91 06 01 	lds	r18, 0x0106
 8a2:	30 91 07 01 	lds	r19, 0x0107
	
	SREG=sreg;
 8a6:	8f bf       	out	0x3f, r24	; 63
	
	return res;
}
 8a8:	c9 01       	movw	r24, r18
 8aa:	08 95       	ret

000008ac <timebase_passedTimeMS>:
uint16_t timebase_passedTimeMS(uint16_t t0)
{
	uint8_t sreg;
	uint16_t res;
	
	sreg=SREG;
 8ac:	4f b7       	in	r20, 0x3f	; 63
	cli();
 8ae:	f8 94       	cli

	res = (uint16_t)(gMilliSecTick-t0);
 8b0:	20 91 06 01 	lds	r18, 0x0106
 8b4:	30 91 07 01 	lds	r19, 0x0107
	
	SREG=sreg;
 8b8:	4f bf       	out	0x3f, r20	; 63
 8ba:	28 1b       	sub	r18, r24
 8bc:	39 0b       	sbc	r19, r25
	
	return res;
}
 8be:	c9 01       	movw	r24, r18
 8c0:	08 95       	ret

000008c2 <delayloop32>:
#include <inttypes.h>

#include "delay.h"

void delayloop32(uint32_t loops) 
{
 8c2:	dc 01       	movw	r26, r24
 8c4:	cb 01       	movw	r24, r22
  __asm__ volatile ( "cp  %A0,__zero_reg__ \n\t"  \
 8c6:	81 15       	cp	r24, r1
 8c8:	91 05       	cpc	r25, r1
 8ca:	a1 05       	cpc	r26, r1
 8cc:	b1 05       	cpc	r27, r1
 8ce:	29 f0       	breq	.+10     	; 0x8da <L_Exit_7>

000008d0 <L_LOOP_7>:
 8d0:	81 50       	subi	r24, 0x01	; 1
 8d2:	90 40       	sbci	r25, 0x00	; 0
 8d4:	a0 40       	sbci	r26, 0x00	; 0
 8d6:	b0 40       	sbci	r27, 0x00	; 0
 8d8:	d9 f7       	brne	.-10     	; 0x8d0 <L_LOOP_7>

000008da <L_Exit_7>:
                     : "=w" (loops)              \
					 : "0"  (loops)              \
                   );                             \
    
	return;
}
 8da:	08 95       	ret

000008dc <_exit>:
 8dc:	f8 94       	cli

000008de <__stop_program>:
 8de:	ff cf       	rjmp	.-2      	; 0x8de <__stop_program>
